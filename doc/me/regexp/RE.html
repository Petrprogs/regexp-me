<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_0) on Wed Mar 25 00:08:07 EET 2009 -->
<TITLE>
RE
</TITLE>

<META NAME="date" CONTENT="2009-03-25">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="RE";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../me/regexp/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../me/regexp/CharacterIterator.html" title="interface in me.regexp"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../me/regexp/ReaderCharacterIterator.html" title="class in me.regexp"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?me/regexp/RE.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="RE.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
me.regexp</FONT>
<BR>
Class RE</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>me.regexp.RE</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>RE</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
RE is an efficient, lightweight regular expression evaluator/matcher
 class. Regular expressions are pattern descriptions which enable
 sophisticated matching of strings.  In addition to being able to
 match a string against a pattern, you can also extract parts of the
 match.  This is especially useful in text parsing! Details on the
 syntax of regular expression patterns are given below.

 <p>
 To compile a regular expression (RE), you can simply construct an RE
 matcher object from the string specification of the pattern, like this:

 <pre>
  RE r = new RE("a*b");
 </pre>

 <p>
 Once you have done this, you can call either of the RE.match methods to
 perform matching on a String.  For example:

 <pre>
  boolean matched = r.match("aaaab");
 </pre>

 will cause the boolean matched to be set to true because the
 pattern "a*b" matches the string "aaaab".

 <p>
 If you were interested in the <i>number</i> of a's which matched the
 first part of our example expression, you could change the expression to
 "(a*)b".  Then when you compiled the expression and matched it against
 something like "xaaaab", you would get results like this:

 <pre>
  RE r = new RE("(a*)b");                  // Compile expression
  boolean matched = r.match("xaaaab");     // Match against "xaaaab"

  String wholeExpr = r.getParen(0);        // wholeExpr will be 'aaaab'
  String insideParens = r.getParen(1);     // insideParens will be 'aaaa'

  int startWholeExpr = r.getParenStart(0); // startWholeExpr will be index 1
  int endWholeExpr = r.getParenEnd(0);     // endWholeExpr will be index 6
  int lenWholeExpr = r.getParenLength(0);  // lenWholeExpr will be 5

  int startInside = r.getParenStart(1);    // startInside will be index 1
  int endInside = r.getParenEnd(1);        // endInside will be index 5
  int lenInside = r.getParenLength(1);     // lenInside will be 4
 </pre>

 You can also refer to the contents of a parenthesized expression
 within a regular expression itself.  This is called a
 'backreference'.  The first backreference in a regular expression is
 denoted by \1, the second by \2 and so on.  So the expression:

 <pre>
  ([0-9]+)=\1
 </pre>

 will match any string of the form n=n (like 0=0 or 2=2).

 <p>
 The full regular expression syntax accepted by RE is described here:

 <pre>

  <b><font face=times roman>Characters</font></b>

    <i>unicodeChar</i>   Matches any identical unicode character
    \                    Used to quote a meta-character (like '*')
    \\                   Matches a single '\' character
    \0nnn                Matches a given octal character
    \xhh                 Matches a given 8-bit hexadecimal character
    \\uhhhh              Matches a given 16-bit hexadecimal character
    \t                   Matches an ASCII tab character
    \n                   Matches an ASCII newline character
    \r                   Matches an ASCII return character
    \f                   Matches an ASCII form feed character


  <b><font face=times roman>Character Classes</font></b>

    [abc]                Simple character class
    [a-zA-Z]             Character class with ranges
    [^abc]               Negated character class
 </pre>

 <b>NOTE:</b> Incomplete ranges will be interpreted as &quot;starts
 from zero&quot; or &quot;ends with last character&quot;.
 <br>
 I.e. [-a] is the same as [\\u0000-a], and [a-] is the same as [a-\\uFFFF],
 [-] means &quot;all characters&quot;.

 <pre>

  <b><font face=times roman>Standard POSIX Character Classes</font></b>

    [:alnum:]            Alphanumeric characters.
    [:alpha:]            Alphabetic characters.
    [:blank:]            Space and tab characters.
    [:cntrl:]            Control characters.
    [:digit:]            Numeric characters.
    [:graph:]            Characters that are printable and are also visible.
                         (A space is printable, but not visible, while an
                         `a' is both.)
    [:lower:]            Lower-case alphabetic characters.
    [:print:]            Printable characters (characters that are not
                         control characters.)
    [:punct:]            Punctuation characters (characters that are not letter,
                         digits, control characters, or space characters).
    [:space:]            Space characters (such as space, tab, and formfeed,
                         to name a few).
    [:upper:]            Upper-case alphabetic characters.
    [:xdigit:]           Characters that are hexadecimal digits.


  <b><font face=times roman>Non-standard POSIX-style Character Classes</font></b>

    [:javastart:]        Start of a Java identifier
    [:javapart:]         Part of a Java identifier


  <b><font face=times roman>Predefined Classes</font></b>

    .         Matches any character other than newline
    \w        Matches a "word" character (alphanumeric plus "_")
    \W        Matches a non-word character
    \s        Matches a whitespace character
    \S        Matches a non-whitespace character
    \d        Matches a digit character
    \D        Matches a non-digit character


  <b><font face=times roman>Boundary Matchers</font></b>

    ^         Matches only at the beginning of a line
    $         Matches only at the end of a line
    \b        Matches only at a word boundary
    \B        Matches only at a non-word boundary


  <b><font face=times roman>Greedy Closures</font></b>

    A*        Matches A 0 or more times (greedy)
    A+        Matches A 1 or more times (greedy)
    A?        Matches A 1 or 0 times (greedy)
    A{n}      Matches A exactly n times (greedy)
    A{n,}     Matches A at least n times (greedy)
    A{n,m}    Matches A at least n but not more than m times (greedy)


  <b><font face=times roman>Reluctant Closures</font></b>

    A*?       Matches A 0 or more times (reluctant)
    A+?       Matches A 1 or more times (reluctant)
    A??       Matches A 0 or 1 times (reluctant)


  <b><font face=times roman>Logical Operators</font></b>

    AB        Matches A followed by B
    A|B       Matches either A or B
    (A)       Used for subexpression grouping
   (?:A)      Used for subexpression clustering (just like grouping but
              no backrefs)


  <b><font face=times roman>Backreferences</font></b>

    \1    Backreference to 1st parenthesized subexpression
    \2    Backreference to 2nd parenthesized subexpression
    \3    Backreference to 3rd parenthesized subexpression
    \4    Backreference to 4th parenthesized subexpression
    \5    Backreference to 5th parenthesized subexpression
    \6    Backreference to 6th parenthesized subexpression
    \7    Backreference to 7th parenthesized subexpression
    \8    Backreference to 8th parenthesized subexpression
    \9    Backreference to 9th parenthesized subexpression
 </pre>

 <p>
 All closure operators (+, *, ?, {m,n}) are greedy by default, meaning
 that they match as many elements of the string as possible without
 causing the overall match to fail.  If you want a closure to be
 reluctant (non-greedy), you can simply follow it with a '?'.  A
 reluctant closure will match as few elements of the string as
 possible when finding matches.  {m,n} closures don't currently
 support reluctancy.

 <p>
 <b><font face="times roman">Line terminators</font></b>
 <br>
 A line terminator is a one- or two-character sequence that marks
 the end of a line of the input character sequence. The following
 are recognized as line terminators:
 <ul>
 <li>A newline (line feed) character ('\n'),</li>
 <li>A carriage-return character followed immediately by a newline character ("\r\n"),</li>
 <li>A standalone carriage-return character ('\r'),</li>
 <li>A next-line character (''),</li>
 <li>A line-separator character (' '), or</li>
 <li>A paragraph-separator character (' ).</li>
 </ul>

 <p>
 RE runs programs compiled by the RECompiler class.  But the RE
 matcher class does not include the actual regular expression compiler
 for reasons of efficiency. You can construct a single RECompiler object and
 re-use it to compile each expression. Similarly, you can change the
 program run by a given matcher object at any time. However, RE and
 RECompiler are not threadsafe (for efficiency reasons, and because
 requiring thread safety in this class is deemed to be a rare
 requirement), so you will need to construct a separate compiler or
 matcher object for each thread (unless you do thread synchronization
 yourself). Once expression compiled into the REProgram object, REProgram
 can be safely shared across multiple threads and RE objects.

 <br><p><br>

 <font color="red">
 <i>ISSUES:</i>

 <ul>
  <li>com.weusours.util.re is not currently compatible with all
      standard POSIX regcomp flags</li>
  <li>com.weusours.util.re does not support POSIX equivalence classes
      ([=foo=] syntax) (I18N/locale issue)</li>
  <li>com.weusours.util.re does not support nested POSIX character
      classes (definitely should, but not completely trivial)</li>
  <li>com.weusours.util.re Does not support POSIX character collation
      concepts ([.foo.] syntax) (I18N/locale issue)</li>
  <li>Should there be different matching styles (simple, POSIX, Perl etc?)</li>
  <li>Should RE support character iterators (for backwards RE matching!)?</li>
  <li>Should RE support reluctant {m,n} closures (does anyone care)?</li>
  <li>Not *all* possibilities are considered for greediness when backreferences
      are involved (as POSIX suggests should be the case).  The POSIX RE
      "(ac*)c*d[ac]*\1", when matched against "acdacaa" should yield a match
      of acdacaa where \1 is "a".  This is not the case in this RE package,
      and actually Perl doesn't go to this extent either!  Until someone
      actually complains about this, I'm not sure it's worth "fixing".
      If it ever is fixed, test #137 in RETest.txt should be updated.</li>
 </ul>

 </font>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../me/regexp/RECompiler.html" title="class in me.regexp"><CODE>RECompiler</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#MATCH_CASEINDEPENDENT">MATCH_CASEINDEPENDENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag to indicate that matching should be case-independent (folded)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#MATCH_MULTILINE">MATCH_MULTILINE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newlines should match as BOL/EOL (^ and $)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#MATCH_NORMAL">MATCH_NORMAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies normal, case-sensitive matching behaviour.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#MATCH_SINGLELINE">MATCH_SINGLELINE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Consider all input a single body of text - newlines are matched by .</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#REPLACE_ALL">REPLACE_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag bit that indicates that subst should replace all occurrences of this
 regular expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#REPLACE_BACKREFERENCES">REPLACE_BACKREFERENCES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag bit that indicates that subst should replace backreferences</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#REPLACE_FIRSTONLY">REPLACE_FIRSTONLY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag bit that indicates that subst should only replace the first occurrence
 of this regular expression.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../me/regexp/RE.html#RE()">RE</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a regular expression matcher with no initial program.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../me/regexp/RE.html#RE(me.regexp.REProgram)">RE</A></B>(<A HREF="../../me/regexp/REProgram.html" title="class in me.regexp">REProgram</A>&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct a matcher for a pre-compiled regular expression from program
 (bytecode) data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../me/regexp/RE.html#RE(me.regexp.REProgram, int)">RE</A></B>(<A HREF="../../me/regexp/REProgram.html" title="class in me.regexp">REProgram</A>&nbsp;program,
   int&nbsp;matchFlags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct a matcher for a pre-compiled regular expression from program
 (bytecode) data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../me/regexp/RE.html#RE(java.lang.String)">RE</A></B>(java.lang.String&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a regular expression matcher from a String by compiling it
 using a new instance of RECompiler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../me/regexp/RE.html#RE(java.lang.String, int)">RE</A></B>(java.lang.String&nbsp;pattern,
   int&nbsp;matchFlags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a regular expression matcher from a String by compiling it
 using a new instance of RECompiler.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#getMatchFlags()">getMatchFlags</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current match behaviour flags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#getParen(int)">getParen</A></B>(int&nbsp;which)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the contents of a parenthesized subexpression after a successful match.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#getParenCount()">getParenCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of parenthesized subexpressions available after a successful match.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#getParenEnd(int)">getParenEnd</A></B>(int&nbsp;which)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the end index of a given paren level.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#getParenLength(int)">getParenLength</A></B>(int&nbsp;which)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the length of a given paren level.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#getParenStart(int)">getParenStart</A></B>(int&nbsp;which)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the start index of a given paren level.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../me/regexp/REProgram.html" title="class in me.regexp">REProgram</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#getProgram()">getProgram</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current regular expression program in use by this matcher object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#grep(java.lang.Object[])">grep</A></B>(java.lang.Object[]&nbsp;search)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array of Strings, whose toString representation matches a regular
 expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#internalError(java.lang.String)">internalError</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throws an Error representing an internal error condition probably resulting
 from a bug in the regular expression compiler (or possibly data corruption).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#match(me.regexp.CharacterIterator, int)">match</A></B>(<A HREF="../../me/regexp/CharacterIterator.html" title="interface in me.regexp">CharacterIterator</A>&nbsp;search,
      int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matches the current regular expression program against a character array,
 starting at a given index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#match(java.lang.String)">match</A></B>(java.lang.String&nbsp;search)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matches the current regular expression program against a String.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#match(java.lang.String, int)">match</A></B>(java.lang.String&nbsp;search,
      int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matches the current regular expression program against a character array,
 starting at a given index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#matchAt(int)">matchAt</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match the current regular expression program against the current
 input string, starting at index i of the input string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#matchNodes(int, int, int)">matchNodes</A></B>(int&nbsp;firstNode,
           int&nbsp;lastNode,
           int&nbsp;idxStart)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Try to match a string against a subset of nodes in the program</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#setMatchFlags(int)">setMatchFlags</A></B>(int&nbsp;matchFlags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets match behaviour flags which alter the way RE does matching.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#setParenEnd(int, int)">setParenEnd</A></B>(int&nbsp;which,
            int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the end of a paren level</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#setParenStart(int, int)">setParenStart</A></B>(int&nbsp;which,
              int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the start of a paren level</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#setProgram(me.regexp.REProgram)">setProgram</A></B>(<A HREF="../../me/regexp/REProgram.html" title="class in me.regexp">REProgram</A>&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current regular expression program used by this matcher object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#simplePatternToFullRegularExpression(java.lang.String)">simplePatternToFullRegularExpression</A></B>(java.lang.String&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a 'simplified' regular expression to a full regular expression</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#split(java.lang.String)">split</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splits a string into an array of strings on regular expression boundaries.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#subst(java.lang.String, java.lang.String)">subst</A></B>(java.lang.String&nbsp;substituteIn,
      java.lang.String&nbsp;substitution)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Substitutes a string for this regular expression in another string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../me/regexp/RE.html#subst(java.lang.String, java.lang.String, int)">subst</A></B>(java.lang.String&nbsp;substituteIn,
      java.lang.String&nbsp;substitution,
      int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Substitutes a string for this regular expression in another string.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MATCH_NORMAL"><!-- --></A><H3>
MATCH_NORMAL</H3>
<PRE>
public static final int <B>MATCH_NORMAL</B></PRE>
<DL>
<DD>Specifies normal, case-sensitive matching behaviour.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#me.regexp.RE.MATCH_NORMAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MATCH_CASEINDEPENDENT"><!-- --></A><H3>
MATCH_CASEINDEPENDENT</H3>
<PRE>
public static final int <B>MATCH_CASEINDEPENDENT</B></PRE>
<DL>
<DD>Flag to indicate that matching should be case-independent (folded)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#me.regexp.RE.MATCH_CASEINDEPENDENT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MATCH_MULTILINE"><!-- --></A><H3>
MATCH_MULTILINE</H3>
<PRE>
public static final int <B>MATCH_MULTILINE</B></PRE>
<DL>
<DD>Newlines should match as BOL/EOL (^ and $)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#me.regexp.RE.MATCH_MULTILINE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MATCH_SINGLELINE"><!-- --></A><H3>
MATCH_SINGLELINE</H3>
<PRE>
public static final int <B>MATCH_SINGLELINE</B></PRE>
<DL>
<DD>Consider all input a single body of text - newlines are matched by .
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#me.regexp.RE.MATCH_SINGLELINE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="REPLACE_ALL"><!-- --></A><H3>
REPLACE_ALL</H3>
<PRE>
public static final int <B>REPLACE_ALL</B></PRE>
<DL>
<DD>Flag bit that indicates that subst should replace all occurrences of this
 regular expression.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#me.regexp.RE.REPLACE_ALL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="REPLACE_FIRSTONLY"><!-- --></A><H3>
REPLACE_FIRSTONLY</H3>
<PRE>
public static final int <B>REPLACE_FIRSTONLY</B></PRE>
<DL>
<DD>Flag bit that indicates that subst should only replace the first occurrence
 of this regular expression.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#me.regexp.RE.REPLACE_FIRSTONLY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="REPLACE_BACKREFERENCES"><!-- --></A><H3>
REPLACE_BACKREFERENCES</H3>
<PRE>
public static final int <B>REPLACE_BACKREFERENCES</B></PRE>
<DL>
<DD>Flag bit that indicates that subst should replace backreferences
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#me.regexp.RE.REPLACE_BACKREFERENCES">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="RE(java.lang.String)"><!-- --></A><H3>
RE</H3>
<PRE>
public <B>RE</B>(java.lang.String&nbsp;pattern)
   throws <A HREF="../../me/regexp/RESyntaxException.html" title="class in me.regexp">RESyntaxException</A></PRE>
<DL>
<DD>Constructs a regular expression matcher from a String by compiling it
 using a new instance of RECompiler.  If you will be compiling many
 expressions, you may prefer to use a single RECompiler object instead.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - The regular expression pattern to compile.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../me/regexp/RESyntaxException.html" title="class in me.regexp">RESyntaxException</A></CODE> - Thrown if the regular expression has invalid syntax.<DT><B>See Also:</B><DD><A HREF="../../me/regexp/RECompiler.html" title="class in me.regexp"><CODE>RECompiler</CODE></A></DL>
</DL>
<HR>

<A NAME="RE(java.lang.String, int)"><!-- --></A><H3>
RE</H3>
<PRE>
public <B>RE</B>(java.lang.String&nbsp;pattern,
          int&nbsp;matchFlags)
   throws <A HREF="../../me/regexp/RESyntaxException.html" title="class in me.regexp">RESyntaxException</A></PRE>
<DL>
<DD>Constructs a regular expression matcher from a String by compiling it
 using a new instance of RECompiler.  If you will be compiling many
 expressions, you may prefer to use a single RECompiler object instead.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - The regular expression pattern to compile.<DD><CODE>matchFlags</CODE> - The matching style
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../me/regexp/RESyntaxException.html" title="class in me.regexp">RESyntaxException</A></CODE> - Thrown if the regular expression has invalid syntax.<DT><B>See Also:</B><DD><A HREF="../../me/regexp/RECompiler.html" title="class in me.regexp"><CODE>RECompiler</CODE></A></DL>
</DL>
<HR>

<A NAME="RE(me.regexp.REProgram, int)"><!-- --></A><H3>
RE</H3>
<PRE>
public <B>RE</B>(<A HREF="../../me/regexp/REProgram.html" title="class in me.regexp">REProgram</A>&nbsp;program,
          int&nbsp;matchFlags)</PRE>
<DL>
<DD>Construct a matcher for a pre-compiled regular expression from program
 (bytecode) data.  Permits special flags to be passed in to modify matching
 behaviour.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Compiled regular expression program (see RECompiler)<DD><CODE>matchFlags</CODE> - One or more of the RE match behaviour flags (RE.MATCH_*):

 <pre>
   MATCH_NORMAL              // Normal (case-sensitive) matching
   MATCH_CASEINDEPENDENT     // Case folded comparisons
   MATCH_MULTILINE           // Newline matches as BOL/EOL
 </pre><DT><B>See Also:</B><DD><A HREF="../../me/regexp/RECompiler.html" title="class in me.regexp"><CODE>RECompiler</CODE></A>, 
<A HREF="../../me/regexp/REProgram.html" title="class in me.regexp"><CODE>REProgram</CODE></A></DL>
</DL>
<HR>

<A NAME="RE(me.regexp.REProgram)"><!-- --></A><H3>
RE</H3>
<PRE>
public <B>RE</B>(<A HREF="../../me/regexp/REProgram.html" title="class in me.regexp">REProgram</A>&nbsp;program)</PRE>
<DL>
<DD>Construct a matcher for a pre-compiled regular expression from program
 (bytecode) data.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Compiled regular expression program<DT><B>See Also:</B><DD><A HREF="../../me/regexp/RECompiler.html" title="class in me.regexp"><CODE>RECompiler</CODE></A></DL>
</DL>
<HR>

<A NAME="RE()"><!-- --></A><H3>
RE</H3>
<PRE>
public <B>RE</B>()</PRE>
<DL>
<DD>Constructs a regular expression matcher with no initial program.
 This is likely to be an uncommon practice, but is still supported.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="simplePatternToFullRegularExpression(java.lang.String)"><!-- --></A><H3>
simplePatternToFullRegularExpression</H3>
<PRE>
public static java.lang.String <B>simplePatternToFullRegularExpression</B>(java.lang.String&nbsp;pattern)</PRE>
<DL>
<DD>Converts a 'simplified' regular expression to a full regular expression
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - The pattern to convert
<DT><B>Returns:</B><DD>The full regular expression</DL>
</DD>
</DL>
<HR>

<A NAME="setMatchFlags(int)"><!-- --></A><H3>
setMatchFlags</H3>
<PRE>
public void <B>setMatchFlags</B>(int&nbsp;matchFlags)</PRE>
<DL>
<DD>Sets match behaviour flags which alter the way RE does matching.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>matchFlags</CODE> - One or more of the RE match behaviour flags (RE.MATCH_*):

 <pre>
   MATCH_NORMAL              // Normal (case-sensitive) matching
   MATCH_CASEINDEPENDENT     // Case folded comparisons
   MATCH_MULTILINE           // Newline matches as BOL/EOL
 </pre></DL>
</DD>
</DL>
<HR>

<A NAME="getMatchFlags()"><!-- --></A><H3>
getMatchFlags</H3>
<PRE>
public int <B>getMatchFlags</B>()</PRE>
<DL>
<DD>Returns the current match behaviour flags.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Current match behaviour flags (RE.MATCH_*).

 <pre>
   MATCH_NORMAL              // Normal (case-sensitive) matching
   MATCH_CASEINDEPENDENT     // Case folded comparisons
   MATCH_MULTILINE           // Newline matches as BOL/EOL
 </pre><DT><B>See Also:</B><DD><A HREF="../../me/regexp/RE.html#setMatchFlags(int)"><CODE>setMatchFlags(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setProgram(me.regexp.REProgram)"><!-- --></A><H3>
setProgram</H3>
<PRE>
public void <B>setProgram</B>(<A HREF="../../me/regexp/REProgram.html" title="class in me.regexp">REProgram</A>&nbsp;program)</PRE>
<DL>
<DD>Sets the current regular expression program used by this matcher object.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Regular expression program compiled by RECompiler.<DT><B>See Also:</B><DD><A HREF="../../me/regexp/RECompiler.html" title="class in me.regexp"><CODE>RECompiler</CODE></A>, 
<A HREF="../../me/regexp/REProgram.html" title="class in me.regexp"><CODE>REProgram</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getProgram()"><!-- --></A><H3>
getProgram</H3>
<PRE>
public <A HREF="../../me/regexp/REProgram.html" title="class in me.regexp">REProgram</A> <B>getProgram</B>()</PRE>
<DL>
<DD>Returns the current regular expression program in use by this matcher object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Regular expression program<DT><B>See Also:</B><DD><A HREF="../../me/regexp/RE.html#setProgram(me.regexp.REProgram)"><CODE>setProgram(me.regexp.REProgram)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getParenCount()"><!-- --></A><H3>
getParenCount</H3>
<PRE>
public int <B>getParenCount</B>()</PRE>
<DL>
<DD>Returns the number of parenthesized subexpressions available after a successful match.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Number of available parenthesized subexpressions</DL>
</DD>
</DL>
<HR>

<A NAME="getParen(int)"><!-- --></A><H3>
getParen</H3>
<PRE>
public java.lang.String <B>getParen</B>(int&nbsp;which)</PRE>
<DL>
<DD>Gets the contents of a parenthesized subexpression after a successful match.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>which</CODE> - Nesting level of subexpression
<DT><B>Returns:</B><DD>String</DL>
</DD>
</DL>
<HR>

<A NAME="getParenStart(int)"><!-- --></A><H3>
getParenStart</H3>
<PRE>
public final int <B>getParenStart</B>(int&nbsp;which)</PRE>
<DL>
<DD>Returns the start index of a given paren level.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>which</CODE> - Nesting level of subexpression
<DT><B>Returns:</B><DD>String index</DL>
</DD>
</DL>
<HR>

<A NAME="getParenEnd(int)"><!-- --></A><H3>
getParenEnd</H3>
<PRE>
public final int <B>getParenEnd</B>(int&nbsp;which)</PRE>
<DL>
<DD>Returns the end index of a given paren level.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>which</CODE> - Nesting level of subexpression
<DT><B>Returns:</B><DD>String index</DL>
</DD>
</DL>
<HR>

<A NAME="getParenLength(int)"><!-- --></A><H3>
getParenLength</H3>
<PRE>
public final int <B>getParenLength</B>(int&nbsp;which)</PRE>
<DL>
<DD>Returns the length of a given paren level.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>which</CODE> - Nesting level of subexpression
<DT><B>Returns:</B><DD>Number of characters in the parenthesized subexpression</DL>
</DD>
</DL>
<HR>

<A NAME="setParenStart(int, int)"><!-- --></A><H3>
setParenStart</H3>
<PRE>
protected final void <B>setParenStart</B>(int&nbsp;which,
                                   int&nbsp;i)</PRE>
<DL>
<DD>Sets the start of a paren level
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>which</CODE> - Which paren level<DD><CODE>i</CODE> - Index in input array</DL>
</DD>
</DL>
<HR>

<A NAME="setParenEnd(int, int)"><!-- --></A><H3>
setParenEnd</H3>
<PRE>
protected final void <B>setParenEnd</B>(int&nbsp;which,
                                 int&nbsp;i)</PRE>
<DL>
<DD>Sets the end of a paren level
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>which</CODE> - Which paren level<DD><CODE>i</CODE> - Index in input array</DL>
</DD>
</DL>
<HR>

<A NAME="internalError(java.lang.String)"><!-- --></A><H3>
internalError</H3>
<PRE>
protected void <B>internalError</B>(java.lang.String&nbsp;s)
                      throws java.lang.Error</PRE>
<DL>
<DD>Throws an Error representing an internal error condition probably resulting
 from a bug in the regular expression compiler (or possibly data corruption).
 In practice, this should be very rare.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - Error description
<DT><B>Throws:</B>
<DD><CODE>java.lang.Error</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="matchNodes(int, int, int)"><!-- --></A><H3>
matchNodes</H3>
<PRE>
protected int <B>matchNodes</B>(int&nbsp;firstNode,
                         int&nbsp;lastNode,
                         int&nbsp;idxStart)</PRE>
<DL>
<DD>Try to match a string against a subset of nodes in the program
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>firstNode</CODE> - Node to start at in program<DD><CODE>lastNode</CODE> - Last valid node (used for matching a subexpression without
                  matching the rest of the program as well).<DD><CODE>idxStart</CODE> - Starting position in character array
<DT><B>Returns:</B><DD>Final input array index if match succeeded.  -1 if not.</DL>
</DD>
</DL>
<HR>

<A NAME="matchAt(int)"><!-- --></A><H3>
matchAt</H3>
<PRE>
protected boolean <B>matchAt</B>(int&nbsp;i)</PRE>
<DL>
<DD>Match the current regular expression program against the current
 input string, starting at index i of the input string.  This method
 is only meant for internal use.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - The input string index to start matching at
<DT><B>Returns:</B><DD>True if the input matched the expression</DL>
</DD>
</DL>
<HR>

<A NAME="match(java.lang.String, int)"><!-- --></A><H3>
match</H3>
<PRE>
public boolean <B>match</B>(java.lang.String&nbsp;search,
                     int&nbsp;i)</PRE>
<DL>
<DD>Matches the current regular expression program against a character array,
 starting at a given index.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>search</CODE> - String to match against<DD><CODE>i</CODE> - Index to start searching at
<DT><B>Returns:</B><DD>True if string matched</DL>
</DD>
</DL>
<HR>

<A NAME="match(me.regexp.CharacterIterator, int)"><!-- --></A><H3>
match</H3>
<PRE>
public boolean <B>match</B>(<A HREF="../../me/regexp/CharacterIterator.html" title="interface in me.regexp">CharacterIterator</A>&nbsp;search,
                     int&nbsp;i)</PRE>
<DL>
<DD>Matches the current regular expression program against a character array,
 starting at a given index.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>search</CODE> - String to match against<DD><CODE>i</CODE> - Index to start searching at
<DT><B>Returns:</B><DD>True if string matched</DL>
</DD>
</DL>
<HR>

<A NAME="match(java.lang.String)"><!-- --></A><H3>
match</H3>
<PRE>
public boolean <B>match</B>(java.lang.String&nbsp;search)</PRE>
<DL>
<DD>Matches the current regular expression program against a String.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>search</CODE> - String to match against
<DT><B>Returns:</B><DD>True if string matched</DL>
</DD>
</DL>
<HR>

<A NAME="split(java.lang.String)"><!-- --></A><H3>
split</H3>
<PRE>
public java.lang.String[] <B>split</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Splits a string into an array of strings on regular expression boundaries.
 This function works the same way as the Perl function of the same name.
 Given a regular expression of "[ab]+" and a string to split of
 "xyzzyababbayyzabbbab123", the result would be the array of Strings
 "[xyzzy, yyz, 123]".

 <p>Please note that the first string in the resulting array may be an empty
 string. This happens when the very first character of input string is
 matched by the pattern.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - String to split on this regular exression
<DT><B>Returns:</B><DD>Array of strings</DL>
</DD>
</DL>
<HR>

<A NAME="subst(java.lang.String, java.lang.String)"><!-- --></A><H3>
subst</H3>
<PRE>
public java.lang.String <B>subst</B>(java.lang.String&nbsp;substituteIn,
                              java.lang.String&nbsp;substitution)</PRE>
<DL>
<DD>Substitutes a string for this regular expression in another string.
 This method works like the Perl function of the same name.
 Given a regular expression of "a*b", a String to substituteIn of
 "aaaabfooaaabgarplyaaabwackyb" and the substitution String "-", the
 resulting String returned by subst would be "-foo-garply-wacky-".
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>substituteIn</CODE> - String to substitute within<DD><CODE>substitution</CODE> - String to substitute for all matches of this regular expression.
<DT><B>Returns:</B><DD>The string substituteIn with zero or more occurrences of the current
 regular expression replaced with the substitution String (if this regular
 expression object doesn't match at any position, the original String is returned
 unchanged).</DL>
</DD>
</DL>
<HR>

<A NAME="subst(java.lang.String, java.lang.String, int)"><!-- --></A><H3>
subst</H3>
<PRE>
public java.lang.String <B>subst</B>(java.lang.String&nbsp;substituteIn,
                              java.lang.String&nbsp;substitution,
                              int&nbsp;flags)</PRE>
<DL>
<DD>Substitutes a string for this regular expression in another string.
 This method works like the Perl function of the same name.
 Given a regular expression of "a*b", a String to substituteIn of
 "aaaabfooaaabgarplyaaabwackyb" and the substitution String "-", the
 resulting String returned by subst would be "-foo-garply-wacky-".
 <p>
 It is also possible to reference the contents of a parenthesized expression
 with $0, $1, ... $9. A regular expression of "http://[\\.\\w\\-\\?/~_@&=%]+",
 a String to substituteIn of "visit us: http://www.apache.org!" and the
 substitution String "&lt;a href=\"$0\"&gt;$0&lt;/a&gt;", the resulting String
 returned by subst would be
 "visit us: &lt;a href=\"http://www.apache.org\"&gt;http://www.apache.org&lt;/a&gt;!".
 <p>
 <i>Note:</i> $0 represents the whole match.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>substituteIn</CODE> - String to substitute within<DD><CODE>substitution</CODE> - String to substitute for matches of this regular expression<DD><CODE>flags</CODE> - One or more bitwise flags from REPLACE_*.  If the REPLACE_FIRSTONLY
 flag bit is set, only the first occurrence of this regular expression is replaced.
 If the bit is not set (REPLACE_ALL), all occurrences of this pattern will be
 replaced. If the flag REPLACE_BACKREFERENCES is set, all backreferences will
 be processed.
<DT><B>Returns:</B><DD>The string substituteIn with zero or more occurrences of the current
 regular expression replaced with the substitution String (if this regular
 expression object doesn't match at any position, the original String is returned
 unchanged).</DL>
</DD>
</DL>
<HR>

<A NAME="grep(java.lang.Object[])"><!-- --></A><H3>
grep</H3>
<PRE>
public java.lang.String[] <B>grep</B>(java.lang.Object[]&nbsp;search)</PRE>
<DL>
<DD>Returns an array of Strings, whose toString representation matches a regular
 expression. This method works like the Perl function of the same name.  Given
 a regular expression of "a*b" and an array of String objects of [foo, aab, zzz,
 aaaab], the array of Strings returned by grep would be [aab, aaaab].
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>search</CODE> - Array of Objects to search
<DT><B>Returns:</B><DD>Array of Strings whose toString() value matches this regular expression.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../me/regexp/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../me/regexp/CharacterIterator.html" title="interface in me.regexp"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../me/regexp/ReaderCharacterIterator.html" title="class in me.regexp"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?me/regexp/RE.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="RE.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
